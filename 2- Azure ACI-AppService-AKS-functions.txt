
MsolService : Ancien accès à azure AD via le module MSOnline
Azure AD : module pour gérer Entra-ID via PowerShell
ExchangeOnline : module qui permet d'administrer exchange d'O365 (mailboxes …)
Microsoft Graph API : accès moderne à Microsoft 365, il gère tout : Entra-ID, M365 … via le module Microsoft.Graph
Azure ARM/REST APIs : Gérer les ressources Azure comme VMs, réseaux ...

Connect-AzAccount
Get-AzSubscription

Connect-AzureAD
Get-AzureADUser -ObjectId "soufiane.talibi@castel-afrique.com" | Format-List *

Connect-MgGraph -Scopes "User.Read.All"
Get-MgUser -UserId "soufiane.talibi@castel-afrique.com"

 Gérer les boites mails O365
Connect-ExchangeOnline
Get-MailboxStatistics -Identity "soufiane.talibi@castel-afrique.com" | 
    Select DisplayName, TotalItemSize, ItemCount

======================================================================================================

 Les 4 types de compute dans le cloud : 

-Machines virtuelles (VM – Virtual Machines)

-Containers as a Service : l'application et ses dépendances.

-Functions as a Service : Conteneurs serverless qui execute un code à la demande.

Logic Apps vs functions : 
Logic Apps : créer un flux de travail visuel suite à un trigger ( HTTP request, timer, email reçu, storage event "blob", queue/service bus "un nv msg", event Grid, webhook...)
functions : execution d'un code "C#, JS, Python..." suite à un trigger aussi

Exemple logic apps : 
Bloc 1 : "When a new email arrives on recrutement@consto.com (Outlook 365)" ? Déclencheur.
Bloc 2 : "Condition" ? Si pièce jointe = vrai et format = PDF/DOCX.
Bloc 3 : "Create file (SharePoint)" ? Sauvegarde automatique.
Bloc 4 : "Insert row (Excel)" ? Ajoute dans la base de suivi.
Bloc 5 : "Send message (Teams)" ? Alerte le service RH.

Exemple Azure functions : 
un site ecommerce dépose un message dans azure storage queue "commandes-a-traiter"
déclencheur de la fonction : nouveau msg reçu dans la file d'attente
Lire les infos de la commande depuis le message (JSON).
Mettre à jour la base de données SQL server.
Appeler un service d’email (ex. SendGrid) pour envoyer la confirmation.

=============================================
Conteneurisation sur le cloud :

      1-azure ACI
      2-app service
      3-AKS  
            (Azure ACR est un registry des images comme docker Hub)

 -je crée une VM linux sur le cloud, j'y installe docker,docker-compose et je gère moi même le tout (VM Dockerisée)

 -je veux juste lancer des images docker : azure ACI (conteneur serverless, je crée des conteneurs sans gérer l'infra docker) mais ne supporte pas docker compose

 -je veux déployer une app constituée de  quelques images "php+mysql" comme un docker-compose : app service for containers

 -orchestrer plusieurs conteneurs : Azure AKS

 ==========> azure ACI est idéal pour test, script, API

 ==========> app service for containers est idéal pour une app constituées (php+mysql…)

 ==========> Azure AKS est idéal pour microservices complexes avec CI/CD


======================
App service : 
======================

-Web App : permet de déployer une API ou une app backend uniquement (Node.js, Spring Boot, PHP, etc.), Pas de DB incluse par défaut, il faut l'ajouter manuellement

-Static Web App : App frontend only (React, vue angular) qui peut être connecté à une API serverless (Azure Functions)

-Web App + Database : Apps fullstack (crée un backend + avec base de données incluse) ex :  Express + MySQL , Spring Boot + PostgreSQL

-WordPress on App Service : installe un site vitrine wordpress avec DB. 

Exemple de Web App : 

   application backend Spring Boot uniquement, avec une API REST qui gère des tâches (tasks), sans interface utilisateur (frontend)
  on utilise avec spring boot une base de données relationnelle H2 légère en mémoire (ou en fichier), écrite en Java

  GET /api/tasks – Liste des tâches
  POST /api/tasks – Créer une tâche
  PUT /api/tasks/{id} – Modifier une tâche
  DELETE /api/tasks/{id} – Supprimer une tâche

Accède à l’API :
GET http://localhost:8080/api/tasks
  
Accède à la base :
http://localhost:8080/h2-console
(JDBC URL : jdbc:h2:mem:taskdb, user : sa, password : vide)

=============================================================
On peut créer : 
 -une Web Apps (frontend only ou frontend avec backend)
 -une API Apps (back-end)
 -une Mobile Apps (pour apps mobiles)
--->le backend est souvent connecté à une base de données
    [Frontend] --> [Backend] --> [Azure SQL Database]
--->le frontend only peut être connecté à un azure function qui sera son backend et qui sera à son tour liée à une BD
    [Frontend] --> [Azure Function] --> [Base de données]

+Option 1 : Frontend + Backend séparés

  --> Crée 2 App Services :

  Un pour le frontend (React, Angular, Vue…)

  Un pour le backend (Node.js, .NET, Python…)

Le frontend appelle le backend via son URL publique.

  Base de données séparée (Azure SQL, Cosmos DB…) connectée au backend.

+Option 2 : Backend + Frontend ensemble

    -->Créer une seule app Service : 

 Tu peux servir le frontend directement depuis le backend (ex. Node.js qui sert les fichiers React compilés).

=====================================================

Déployer une app web en conteneur sur Azure
App : Application Flask (Python) exposant une API simple

Objectif : Créer une image Docker, la pousser sur Azure Container Registry (ACR), puis la déployer sur Azure Container Instances (ACI)

=====

Azure Container Instances (ACI)	Déploiements rapides , usage temporaire, facturé lorsque le conteneur est en execution,
Azure App Service for Containers	Web apps  ,avec CI/CD (exemple : une web API Flask avec auto-scaling, URL personnalisée, et SSL)
Azure Kubernetes Service (AKS)	application distribuée, microservices, multi-conteneurs 
Azure Functions (containers)	Conteneurs serverless, traitement des msg de file, webhook, tâche pannifiée, IoT, il s'agit d'une execution légère

Bref : 

ACI : facturé lorsque le conteneur est démarré 
App service, AKS : conteneurisation facturée en continu
Azure functions : facturé à l'exécution


j'ai une image docker sur ACR ou dockerHub et je veux la déployer sur azure :    
-Utiliser ACI si tu veux un conteneur rapide, jetable, souple, et facturé uniquement quand il tourne.
-Utiliser App Service si tu veux héberger une API web 24/7 avec montée en charge automatique et gestion simplifiée.

====Exemple de conteneuriation sur Azure ACI : 

Avoir un serveur linux ayant docker installé.
? Créer une image Docker
? La pousser sur Azure Container Registry (ACR)
? La déployer sur Azure Container Instances (ACI)

 Créer une app simple (Flask) pour conteneurisation
myapp/
+-- app.py
+-- Dockerfile

2. Construire et tester localement
3. Créer Azure Container Registry (ACR) -> comme DockerHub
4. Se connecter à ACR et pousser l'image
5. Déployer sur Azure Container Instances (ACI)
  Accède à l’app via :
    http://myacidemoweb.westeurope.azurecontainer.io
=================================================================

====Exemple de conteneuriation sur Azure App service for containers : 

 1. App de base (ex. Flask)
     myapp/
      +-- app.py
      +-- Dockerfile
    Construire et tester localement
 2. Construire et pousser l’image vers ACR
 3. Créer Azure App Service Plan et Web App
 4. Lier ACR à l’App Service (authentification)
 5. Accès à l’application
    Ton app est accessible via : https://myappwebdemo.azurewebsites.net
 6. Mettre à jour l’image plus tard
    Tu rebuilds localement ? docker push
    Puis tu fais un restart de l’App Service


==>créer un conteneur sur ACI en se basant sur une image ACR : 

az group create --name containers --location francecentral
az container create `
  --resource-group containers `
  --name aci-ms-test `
  --image mcr.microsoft.com/azuredocs/aci-helloworld `
  --dns-name-label aci-ms-test-talibi `
  --ports 80 `
  --os-type Linux `
  --cpu 1 `
  --memory 1.5

==>créer un conteneur sur ACI en se basant sur une image dockerHub : 

az group create --name containers --location francecentral
az container create --resource-group containers --name taskapi-container --image souflouf89/taskapi --dns-name-label taskapi-souflouf89 --ports 80 --os-type Linux --cpu 1 --memory 1.5



    
 
 