Il y a trois faÃ§ons pour lancer docker : 

  1-Faire un pull "docker pull nginx:latest" de limage puis l'exÃ©cuter avec "docker run -d -p 80:80 --name mon-nginx nginx:latest"

  2-Utiliser un dockerfile qui est une sorte de script : 
           1-docker build -t mon-image .  -->pour construire l'image en local   
           2-docker run -d -p 8080:8080 mon-image  --> pour lancer l'image 
       -->Ceci est utile si je veux appeler une image et executer aussi des instructions.

         Exemple : crÃ©er un fichier Dockerfile dans un dossier vide
         contenu : 
               # Dockerfile pour Nginx personnalisÃ© 
                 FROM nginx:latest
               # Copier un fichier index.html personnalisÃ© dans le dossier par dÃ©faut de nginx
                 COPY index.html /usr/share/nginx/html/index.html

         avoir un fichier index.html dans ce dossier

         docker build -t mon-nginx:1.0 .
         docker run -d -p 80:80 --name mon-nginx mon-nginx:1.0
                     
  3-Utiliser un docker-compose.yml pour orchestrer plusieurs conteneurs liÃ©s (frontend + Backend + BDD)
            docker compose build   # Ã‰tape 1 : build des images
            docker compose up      # Ã‰tape 2 : lancement des conteneurs
               en une seule ligne : docker compose up --build

           NB :  si le fichier docker-compose.yml appelle des dockerfiles, ils doivent Ãªtre dans le dossier
                 si le fichier docker-compose.yml appelle uniquement des images dockerhub, rien n'est indisponsable.

Exemple de conteneurs : 

-Conteneur "service web" (API / site web) : docker run -d -p 8080:8080 my-api
  ex : backend Node.js, Flask, FastAPI, Spring Boot, Nginxâ€¦

-Conteneur interactif, terminal pour executer un script : docker run -it python:3.11

-Conteneur qui exÃ©cute un script unique et se ferme : docker run --rm -v "$PWD":/app -w /app python:3.11 python script.py

-Conteneur de base de donnÃ©es / file storage : docker run -d --name mysql-db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=ma_base  mysql:8     
                                               voir les fichiers de la BDD : docker exec -it mysql-db ls /var/lib/mysql  (mais stockage volatile)
          *Pour crÃ©er le conteneur BDD sur un dossier local (avec persistance des donnÃ©es) : 
                   docker run -d \
                     --name mysql-db \
                     -e MYSQL_ROOT_PASSWORD=secret \
                     -e MYSQL_DATABASE=ma_base \
                     -p 3306:3306 \
                     -v /home/user/mysql-data:/var/lib/mysql \
                     mysql:8

          pour accÃ©der Ã  mysql : docker exec -it mysql-db mysql -u root -p        
           

===========================
sudo apt update
sudo apt install docker.io -y
sudo systemctl enable docker
sudo systemctl start docker

sudo usermod -aG docker $USER

docker pull souflouf89/taskapi

docker run -d -p 8080:8080 --name taskapi souflouf89/taskapi

docker ps

http://localhost:8080 

docker stop taskapi

docker rm -f taskapi

====appeler via docker-compose.yml :

version: '3.8'

services:
  taskapi:
    image: souflouf89/taskapi
    container_name: taskapi
    ports:
      - "8080:8080"
    restart: always
=========
docker compose up -d

===============================================

exÃ©cuter un script job.py chaque minute via conteneur : 

python-cron-worker/
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ cronjob
â””â”€â”€ job.py

unzip python-cron-worker.zip
cd python-cron-worker
docker build -t python-cron .
docker run -it --rm python-cron




==Niveaux de conteneurisations : 
1-docker
2-doker-compose
3-kuberneties

crÃ©er un simple conteneur, ex : un conteneur web qui hÃ©berge une page index.html : 
 
html-site/
â”œâ”€â”€ Dockerfile
â””â”€â”€ index.html

contenu du dockerfile : 
FROM nginx:alpine
COPY . /usr/share/nginx/html


docker build -t mon-html-site
docker run -d -p 8080:80 --name html-container mon-html-site

=>dans ce cas, nous avons utilisÃ© l'image nginx:alpine qui provient du dockerhub (le store de docker)

Une image est un modÃ¨le statique pour crÃ©er un conteneur.
 ex, L'image node:20 contient tout ce qui est nÃ©cessaire pour exÃ©cuter une application Node.js sur un serveur Docker

Un conteneur est une instance en cours d'exÃ©cution d'une image Docker

liste des images de conteneurs : 
docker images 

-conteneurs en cours d'execution : 
docker ps

-conteneurs qui existent (dÃ©marrÃ©s ou arrÃªtÃ©s)
docker ps -a

++++ docker-compose.yml : orchestrer plusieurs services (conteneurs) connectÃ©s qui constituent une application.

-dÃ©marrer tous les conteneurs liÃ©s qui constituent une application : (app service on promise)
docker-compose up -d 
docker-compose down

-simple redÃ©marrage : 
docker-compose restart

===redÃ©marrage complet de l'image et ses donnÃ©es : 

docker-compose down --volumes   
docker-compose pull
docker-compose up -d

-dÃ©marrer ou arrÃªter un conteneur : 
docker stop container_ID
docker start container_ID 

docker rm : supprimer un conteneur
docker rmi : supprimer une image

===========================
enfin, mon application est tout simplement un dossier ayant fichier .yml sur sa racine que je peux dÃ©marrer sur n'importe quel serveur ayant docker-compose
 ce serveur va tÃ©lÃ©charger les prÃ©requis (images dockers) pour tourner mon application

le sous dossier app contient : les fichiers index.js (pour node.js), ou index.html login.php ...
                    
====Exemple2, une application mysql+php comme suite : 

php-mysql-app/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ index.php
â””â”€â”€ db/
    â””â”€â”€ init.sql

index.php est le fichier php qui se connecte Ã  la BD et revoie du html et init.sql est le fichier qui crÃ©e la BD mysql et ajoute les donnÃ©es de dÃ©part.

--> j'aurai deux images dockers "php:8.2-apache" et "mariadb:10.5" qui peuvent charger deux conteneurs.

  une fois que c'est chargÃ©, je peux modifier index.php et y ajouter du code, des pages ... pour amÃ©liorer mon site web 
                             ma base MySQL sera prÃ©sente sur /var/lib/MySQL/BD que je peux exporter avec mysqldump "dump.sql" pour l'importer sur un serveur rÃ©el MYSQL en cas de besoin.

  mon application reste tout simplement le dossier "php-mysql-app"
  
point fort : j'utilise MYSQL et apache2-php sans avoir besoin de les installer rÃ©ellement, docker me prÃ©pare l'environnement d'exÃ©cution.


Si j'ai une app qui fonctionne bien, je la convertir en image docker "monapp:1.0" puis le redÃ©ployer  : 

cd mon-app
docker build -t monapp 
docker run -d -p 8080:80 --name app1 monapp


==je peux construire l'image docker puis la transfÃ©rer Ã  dockerHub : 

docker build -t soufianetalibi/testcicd:latest
docker login
docker push soufianetalibi/testcicd:latest

l'image sera disponible sur mon dÃ©pÃ´t.

===============================================

Exemple d'applications : 

-Application Apache2-PHP + MariaDB
-Application Angular+Symfony+MariaDB
-application ASP.NET Core + SQL Server
-Application Apache2-Flask + MariaDB
-Application Node.js + MongoDB
-Application Node.js + DynamoDB
-Application Python Flask + Redis
-Application Flask + OpenAI (chatbot)

Si on utilise Flask par exemple, le backend est Gunicorn.
Si on utilise spring boot par exemple, le backend est tomcat.

===Frontend

HTML5
React (is a Library:  .JSX + html file),
Next.JS (is a Framework based on react)
Vue.js (is a Framework : .JS + html file),
angular (is a Framework .ts + .html )
  we add Bootstrap, Tailwind are used for styling  (Like CSS)

===Backend : 
Langages/frameworks
Javascript Node.js (Express, Next.js, Nest.js)
Python (Django, Gunicorn Flask)
PHP (Laravel, Symfony)
Ruby (Rails)
Java (Spring, tomcat, wildfly, jetty)
Go, Rust, etc.
l'ASP.NET kestrel

   ----> Le Framework d'un langage permet de construire une application complÃ¨te rapidement au lieu de partir du zÃ©ro.

En utilisant un backend en arriÃ¨re plan, les frontends (Apache2, Nginx, Caddy, angular) devient un reverse proxy 

ASP.NET Core est un framework full-stack qui gÃ¨re le frontend et le backend.

===une stack est une constitution de frontend+backend+BD : 

Nom du stack	Frontend	       Backend	       Base de donnÃ©es
MERN	          React  	    Node.js + Express	MongoDB
MEVN           	Vue	            Node.js + Express	MongoDB
LAMP	          PHP	               Apache	          MySQL
Django stack	HTML/React	    Django (Python)	      PostgreSQL/MySQL
Spring Boot	React/Vue/Angular   Spring Boot (Java)	MySQL/PostgreSQL



Exemple de Stack Web complÃ¨te : 

Couches	Stack :         "Classique HTML/PHP"	 "Stack moderne React"
Frontend      :	        HTML + CSS + JS 	React ou Next.js 
Backend	      :             PHP    	        Node.js (ou API Next.js)
Base de donnÃ©es : 	MySQL / MariaDB	        PostgreSQL / MongoDB


--Exemple Hybride : 
Navigateur
  â¬‡ï¸ HTML/CSS/JS
  â¬‡ï¸ React ou Vue (Frontend dynamique)
  â¬‡ï¸ API Fetch
Serveur (Backend)
  â¬‡ï¸ Node.js, PHP, Django...
  â¬‡ï¸ Base de donnÃ©es (MySQL, MongoDB...)

================================================

Conteneurisation sur le cloud : 

 -je crÃ©e une VM linux sur le cloud, j'y installe docker,docker-compose et je gÃ¨re moi mÃªme le tout (VM DockerisÃ©e)
 -je veux juste lancer une simple image docker : azure ACI (conteneur serverless, je crÃ©e une image sans gÃ©rer l'infra docker)
 -je veux dÃ©ployer une app constituÃ©e de  quelques images "php+mysql" comme un docker-compose : app service for containers
 -orchestrer plusieurs conteneurs : Azure AKS

 azure ACI est idÃ©al pour test, script, API
 app service for containers est idÃ©al pour une app constituÃ©es (php+mysqlâ€¦)
 Azure AKS est idÃ©al pour microservices complexes avec CI/CD


-Les types de BDD :  

ğŸ”¹ 1. Bases de donnÃ©es relationnelles (SQL)
OrganisÃ©es en tables avec des relations, elles utilisent le langage SQL.

Exemples :

MySQL / MariaDB (open source, trÃ¨s rÃ©pandues)

PostgreSQL (plus avancÃ©e, supporte JSON, trÃ¨s robuste)

SQLite (lÃ©ger, utilisÃ© localement dans apps mobiles ou desktop)

Oracle Database (commerciale, entreprises)

Microsoft SQL Server (souvent dans l'Ã©cosystÃ¨me Windows)

ğŸ“Œ Usage typique : systÃ¨mes de gestion, ERP, e-commerce, web apps classiques.

ğŸ”¹ 2. Bases de donnÃ©es NoSQL
Ne suivent pas forcÃ©ment le modÃ¨le tabulaire, souvent utilisÃ©es pour la scalabilitÃ© et la flexibilitÃ©.

a. ClÃ©-Valeur
ğŸ”¸ Redis, Riak, DynamoDB

âš¡ Ultra rapides, idÃ©ales pour du cache ou sessions.

b. Document
ğŸ”¸ MongoDB, CouchDB, Firebase Firestore

ğŸ“„ Stockent des documents JSON/BSON. TrÃ¨s flexibles.

c. Colonne
ğŸ”¸ Apache Cassandra, HBase

ğŸ“Š OptimisÃ©es pour les grandes quantitÃ©s de donnÃ©es rÃ©parties (Big Data).

d. Graphes
ğŸ”¸ Neo4j, ArangoDB

ğŸ”— Stockent des nÅ“uds et des relations. IdÃ©al pour rÃ©seaux sociaux, recommandations, etc.

ğŸ”¹ 3. Bases de donnÃ©es orientÃ©es objets
ğŸ”¸ db4o, ObjectDB

ğŸ§± Stockent les objets tels quels (comme en Java).

ğŸ”¹ 4. Bases de donnÃ©es en mÃ©moire
ğŸ”¸ Redis, Memcached

âš¡ TrÃ¨s rapides mais volatiles (sauf en mode persistant). UtilisÃ©es pour le caching.

ğŸ”¹ 5. Bases de donnÃ©es en temps rÃ©el / streaming
ğŸ”¸ InfluxDB, TimescaleDB, Druid

ğŸ“ˆ UtilisÃ©es pour les sÃ©ries temporelles (capteurs, metrics serveur, IoT...).

ğŸ”¹ 6. Bases de donnÃ©es distribuÃ©es
ğŸ”¸ Cassandra, CockroachDB, TiDB

ğŸŒ ConÃ§ues pour la haute disponibilitÃ© et la tolÃ©rance aux pannes.

