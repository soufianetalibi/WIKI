Il y a trois fa√ßons pour lancer docker : 

  1-Faire un pull "docker pull nginx:latest" de limage puis l'ex√©cuter avec "docker run -d -p 80:80 --name mon-nginx nginx:latest"

  2-Utiliser un dockerfile qui est une sorte de script : 
           1-docker build -t mon-image .  -->pour construire l'image en local   
           2-docker run -d -p 8080:8080 mon-image  --> pour lancer l'image 
       -->Ceci est utile si je veux appeler une image et executer aussi des instructions.

         Exemple : cr√©er un fichier Dockerfile dans un dossier vide
         contenu : 
               # Dockerfile pour Nginx personnalis√© 
                 FROM nginx:latest
               # Copier un fichier index.html personnalis√© dans le dossier par d√©faut de nginx
                 COPY index.html /usr/share/nginx/html/index.html

         avoir un fichier index.html dans ce dossier

         docker build -t mon-nginx:1.0 .
         docker run -d -p 80:80 --name mon-nginx mon-nginx:1.0
                     
  3-Utiliser un docker-compose.yml pour orchestrer plusieurs conteneurs li√©s (frontend + Backend + BDD)
            docker compose build   # √âtape 1 : build des images
            docker compose up      # √âtape 2 : lancement des conteneurs
               en une seule ligne : docker compose up --build

           NB :  si le fichier docker-compose.yml appelle des dockerfiles, ils doivent √™tre dans le dossier
                 si le fichier docker-compose.yml appelle uniquement des images dockerhub, rien n'est indisponsable.

Exemple de conteneurs : 

-Conteneur "service web" (API / site web) : docker run -d -p 8080:8080 my-api
  ex : backend Node.js, Flask, FastAPI, Spring Boot, Nginx‚Ä¶

-Conteneur interactif, terminal pour executer un script : docker run -it python:3.11

-Conteneur qui ex√©cute un script unique et se ferme : docker run --rm -v "$PWD":/app -w /app python:3.11 python script.py

-Conteneur de base de donn√©es / file storage : docker run -d --name mysql-db -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=ma_base  mysql:8     
                                               voir les fichiers de la BDD : docker exec -it mysql-db ls /var/lib/mysql  (mais stockage volatile)
          *Pour cr√©er le conteneur BDD sur un dossier local (avec persistance des donn√©es) : 
                   docker run -d \
                     --name mysql-db \
                     -e MYSQL_ROOT_PASSWORD=secret \
                     -e MYSQL_DATABASE=ma_base \
                     -p 3306:3306 \
                     -v /home/user/mysql-data:/var/lib/mysql \
                     mysql:8

          pour acc√©der √† mysql : docker exec -it mysql-db mysql -u root -p        
           

===========================
sudo apt update
sudo apt install docker.io -y
sudo systemctl enable docker
sudo systemctl start docker

sudo usermod -aG docker $USER

docker pull souflouf89/taskapi

docker run -d -p 8080:8080 --name taskapi souflouf89/taskapi

docker ps

http://localhost:8080 

docker stop taskapi

docker rm -f taskapi

====appeler via docker-compose.yml :

version: '3.8'

services:
  taskapi:
    image: souflouf89/taskapi
    container_name: taskapi
    ports:
      - "8080:8080"
    restart: always
=========
docker compose up -d

===============================================

ex√©cuter un script job.py chaque minute via conteneur : 

python-cron-worker/
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ cronjob
‚îî‚îÄ‚îÄ job.py

unzip python-cron-worker.zip
cd python-cron-worker
docker build -t python-cron .
docker run -it --rm python-cron




==Niveaux de conteneurisations : 
1-docker
2-doker-compose
3-kuberneties

cr√©er un simple conteneur, ex : un conteneur web qui h√©berge une page index.html : 
 
html-site/
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ index.html

contenu du dockerfile : 
FROM nginx:alpine
COPY . /usr/share/nginx/html


docker build -t mon-html-site
docker run -d -p 8080:80 --name html-container mon-html-site

=>dans ce cas, nous avons utilis√© l'image nginx:alpine qui provient du dockerhub (le store de docker)

Une image est un mod√®le statique pour cr√©er un conteneur.
 ex, L'image node:20 contient tout ce qui est n√©cessaire pour ex√©cuter une application Node.js sur un serveur Docker

Un conteneur est une instance en cours d'ex√©cution d'une image Docker

liste des images de conteneurs : 
docker images 

-conteneurs en cours d'execution : 
docker ps

-conteneurs qui existent (d√©marr√©s ou arr√™t√©s)
docker ps -a

++++ docker-compose.yml : orchestrer plusieurs services (conteneurs) connect√©s qui constituent une application.

-d√©marrer tous les conteneurs li√©s qui constituent une application : (app service on promise)
docker-compose up -d 
docker-compose down

-simple red√©marrage : 
docker-compose restart

===red√©marrage complet de l'image et ses donn√©es : 

docker-compose down --volumes   
docker-compose pull
docker-compose up -d

-d√©marrer ou arr√™ter un conteneur : 
docker stop container_ID
docker start container_ID 

docker rm : supprimer un conteneur
docker rmi : supprimer une image

===========================
enfin, mon application est tout simplement un dossier ayant fichier .yml sur sa racine que je peux d√©marrer sur n'importe quel serveur ayant docker-compose
 ce serveur va t√©l√©charger les pr√©requis (images dockers) pour tourner mon application

le sous dossier app contient : les fichiers index.js (pour node.js), ou index.html login.php ...
                    
====Exemple2, une application mysql+php comme suite : 

php-mysql-app/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ index.php
‚îî‚îÄ‚îÄ db/
    ‚îî‚îÄ‚îÄ init.sql

index.php est le fichier php qui se connecte √† la BD et revoie du html et init.sql est le fichier qui cr√©e la BD mysql et ajoute les donn√©es de d√©part.

--> j'aurai deux images dockers "php:8.2-apache" et "mariadb:10.5" qui peuvent charger deux conteneurs.

  une fois que c'est charg√©, je peux modifier index.php et y ajouter du code, des pages ... pour am√©liorer mon site web 
                             ma base MySQL sera pr√©sente sur /var/lib/MySQL/BD que je peux exporter avec mysqldump "dump.sql" pour l'importer sur un serveur r√©el MYSQL en cas de besoin.

  mon application reste tout simplement le dossier "php-mysql-app"
  
point fort : j'utilise MYSQL et apache2-php sans avoir besoin de les installer r√©ellement, docker me pr√©pare l'environnement d'ex√©cution.


Si j'ai une app qui fonctionne bien, je la convertir en image docker "monapp:1.0" puis le red√©ployer  : 

cd mon-app
docker build -t monapp 
docker run -d -p 8080:80 --name app1 monapp


==je peux construire l'image docker puis la transf√©rer √† dockerHub : 

docker build -t soufianetalibi/testcicd:latest
docker login
docker push soufianetalibi/testcicd:latest

l'image sera disponible sur mon d√©p√¥t.

===============================================

Exemple d'applications : 

-Application Apache2-PHP + MariaDB
-Application Angular+Symfony+MariaDB
-application ASP.NET Core + SQL Server
-Application Apache2-Flask + MariaDB
-Application Node.js + MongoDB
-Application Node.js + DynamoDB
-Application Python Flask + Redis
-Application Flask + OpenAI (chatbot)

Si on utilise Flask par exemple, le backend est Gunicorn.
Si on utilise spring boot par exemple, le backend est tomcat.

===Frontend

HTML5
React (is a Library:  .JSX + html file),
Next.JS (is a Framework based on react)
Vue.js (is a Framework : .JS + html file),
angular (is a Framework .ts + .html )
  we add Bootstrap, Tailwind are used for styling  (Like CSS)

===Backend : 
Langages/frameworks
Javascript Node.js (Express, Next.js, Nest.js)
Python (Django, Gunicorn Flask)
PHP (Laravel, Symfony)
Ruby (Rails)
Java (Spring, tomcat, wildfly, jetty)
Go, Rust, etc.
l'ASP.NET kestrel

   ----> Le Framework d'un langage permet de construire une application compl√®te rapidement au lieu de partir du z√©ro.

En utilisant un backend en arri√®re plan, les frontends (Apache2, Nginx, Caddy, angular) devient un reverse proxy 

ASP.NET Core est un framework full-stack qui g√®re le frontend et le backend.

===une stack est une constitution de frontend+backend+BD : 

Nom du stack	Frontend	       Backend	       Base de donn√©es
MERN	          React  	    Node.js + Express	MongoDB
MEVN           	Vue	            Node.js + Express	MongoDB
LAMP	          PHP	               Apache	          MySQL
Django stack	HTML/React	    Django (Python)	      PostgreSQL/MySQL
Spring Boot	React/Vue/Angular   Spring Boot (Java)	MySQL/PostgreSQL



Exemple de Stack Web compl√®te : 

Couches	Stack :         "Classique HTML/PHP"	 "Stack moderne React"
Frontend      :	        HTML + CSS + JS 	React ou Next.js 
Backend	      :             PHP    	        Node.js (ou API Next.js)
Base de donn√©es : 	MySQL / MariaDB	        PostgreSQL / MongoDB


--Exemple Hybride : 
Navigateur
  ‚¨áÔ∏è HTML/CSS/JS
  ‚¨áÔ∏è React ou Vue (Frontend dynamique)
  ‚¨áÔ∏è API Fetch
Serveur (Backend)
  ‚¨áÔ∏è Node.js, PHP, Django...
  ‚¨áÔ∏è Base de donn√©es (MySQL, MongoDB...)

================================================

Conteneurisation sur le cloud : 

 -je cr√©e une VM linux sur le cloud, j'y installe docker,docker-compose et je g√®re moi m√™me le tout (VM Dockeris√©e)
 -je veux juste lancer une simple image docker : azure ACI (conteneur serverless, je cr√©e une image sans g√©rer l'infra docker)
 -je veux d√©ployer une app constitu√©e de  quelques images "php+mysql" comme un docker-compose : app service for containers
 -orchestrer plusieurs conteneurs : Azure AKS

 azure ACI est id√©al pour test, script, API
 app service for containers est id√©al pour une app constitu√©es (php+mysql‚Ä¶)
 Azure AKS est id√©al pour microservices complexes avec CI/CD


-Les types de BDD :  

üîπ 1. Bases de donn√©es relationnelles (SQL)
Organis√©es en tables avec des relations, elles utilisent le langage SQL.

Exemples :

MySQL / MariaDB (open source, tr√®s r√©pandues)

PostgreSQL (plus avanc√©e, supporte JSON, tr√®s robuste)

SQLite (l√©ger, utilis√© localement dans apps mobiles ou desktop)

Oracle Database (commerciale, entreprises)

Microsoft SQL Server (souvent dans l'√©cosyst√®me Windows)

üìå Usage typique : syst√®mes de gestion, ERP, e-commerce, web apps classiques.

üîπ 2. Bases de donn√©es NoSQL
Ne suivent pas forc√©ment le mod√®le tabulaire, souvent utilis√©es pour la scalabilit√© et la flexibilit√©.

a. Cl√©-Valeur
üî∏ Redis, Riak, DynamoDB

‚ö° Ultra rapides, id√©ales pour du cache ou sessions.

b. Document
üî∏ MongoDB, CouchDB, Firebase Firestore

üìÑ Stockent des documents JSON/BSON. Tr√®s flexibles.

c. Colonne
üî∏ Apache Cassandra, HBase

üìä Optimis√©es pour les grandes quantit√©s de donn√©es r√©parties (Big Data).

d. Graphes
üî∏ Neo4j, ArangoDB

üîó Stockent des n≈ìuds et des relations. Id√©al pour r√©seaux sociaux, recommandations, etc.

üîπ 3. Bases de donn√©es orient√©es objets
üî∏ db4o, ObjectDB

üß± Stockent les objets tels quels (comme en Java).

üîπ 4. Bases de donn√©es en m√©moire
üî∏ Redis, Memcached

‚ö° Tr√®s rapides mais volatiles (sauf en mode persistant). Utilis√©es pour le caching.

üîπ 5. Bases de donn√©es en temps r√©el / streaming
üî∏ InfluxDB, TimescaleDB, Druid

üìà Utilis√©es pour les s√©ries temporelles (capteurs, metrics serveur, IoT...).

üîπ 6. Bases de donn√©es distribu√©es
üî∏ Cassandra, CockroachDB, TiDB

üåç Con√ßues pour la haute disponibilit√© et la tol√©rance aux pannes.

